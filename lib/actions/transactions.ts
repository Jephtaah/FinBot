'use server'

import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'
import { revalidatePath } from 'next/cache'
import { 
  createTransactionSchema, 
  updateTransactionSchema, 
  type CreateTransactionData, 
  type UpdateTransactionData 
} from '@/lib/validations/transaction'
import type { Transaction, TransactionInsert } from '@/types/database'

/**
 * Get current user ID or redirect to login
 */
async function getCurrentUserId() {
  const supabase = await createClient()
  const { data: { user }, error } = await supabase.auth.getUser()
  
  if (error) {
    console.error('Auth error in getCurrentUserId:', error)
    redirect('/auth/login')
  }
  
  if (!user) {
    console.log('No user found, redirecting to login')
    redirect('/auth/login')
  }
  
  // Ensure user has a profile record
  try {
    const { data: profile } = await supabase
      .from('profiles')
      .select('id')
      .eq('id', user.id)
      .single()
    
    if (!profile) {
      // Create profile if it doesn't exist
      await supabase
        .from('profiles')
        .insert({
          id: user.id,
          email: user.email || '',
          role: 'user'
        })
    }
  } catch (profileError) {
    console.log('Profile check/creation failed:', profileError)
    // Continue anyway - the user might still be able to access their data
  }
  
  return user.id
}

/**
 * Create a new transaction
 */
export async function createTransaction(data: CreateTransactionData) {
  try {
    // Validate input data
    const validatedData = createTransactionSchema.parse(data)
    
    const userId = await getCurrentUserId()
    const supabase = await createClient()
    
    // Prepare transaction data for insertion
    const transactionData: Omit<TransactionInsert, 'id' | 'created_at' | 'updated_at'> = {
      user_id: userId,
      title: validatedData.title,
      slug: '', // This will be auto-generated by the trigger
      type: validatedData.type,
      amount: validatedData.amount,
      category: validatedData.category,
      date: validatedData.date,
      notes: validatedData.notes || {},
      receipt_url: validatedData.receipt_url || null,
    }
    
    const { data: transaction, error } = await supabase
      .from('transactions')
      .insert(transactionData)
      .select()
      .single()
    
    if (error) {
      console.error('Error creating transaction:', error)
      return { success: false, error: 'Failed to create transaction' }
    }
    
    revalidatePath('/dashboard/transactions')
    return { success: true, data: transaction }
  } catch (error) {
    console.error('Error in createTransaction:', error)
    return { success: false, error: 'Invalid transaction data' }
  }
}

/**
 * Get a transaction by slug for the current user
 */
export async function getTransactionBySlug(slug: string): Promise<Transaction | null> {
  try {
    const userId = await getCurrentUserId()
    const supabase = await createClient()
    
    const { data, error } = await supabase
      .from('transactions')
      .select('*')
      .eq('slug', slug)
      .eq('user_id', userId)
      .single()
    
    if (error) {
      // Only log errors if they're not "no rows found" errors (which are expected for 404s)
      if (error.code !== 'PGRST116') {
        console.error('Error fetching transaction:', {
          slug,
          errorMessage: error.message,
          errorCode: error.code
        })
      }
      return null
    }
    
    return data
  } catch (error) {
    // Check if this is a redirect error from authentication
    if (error instanceof Error && error.message === 'NEXT_REDIRECT') {
      throw error // Re-throw redirect errors
    }
    
    console.error('Error in getTransactionBySlug:', {
      slug,
      errorMessage: error instanceof Error ? error.message : 'Unknown error'
    })
    return null
  }
}

/**
 * Get all transactions for the current user
 */
export async function getUserTransactions(): Promise<Transaction[]> {
  try {
    const userId = await getCurrentUserId()
    const supabase = await createClient()
    
    const { data, error } = await supabase
      .from('transactions')
      .select('*')
      .eq('user_id', userId)
      .order('date', { ascending: false })
      .order('created_at', { ascending: false })
    
    if (error) {
      console.error('Error fetching transactions:', {
        message: error.message,
        details: error.details,
        hint: error.hint,
        code: error.code,
        userId: userId
      })
      return []
    }
    
    return data || []
  } catch (error) {
    console.error('Error in getUserTransactions:', error)
    return []
  }
}

/**
 * Update a transaction by slug
 */
export async function updateTransaction(slug: string, updates: UpdateTransactionData) {
  try {
    // Validate input data
    const validatedUpdates = updateTransactionSchema.parse(updates)
    
    const userId = await getCurrentUserId()
    const supabase = await createClient()
    
    // First check if the transaction exists and belongs to the user
    const { data: existingTransaction } = await supabase
      .from('transactions')
      .select('id')
      .eq('slug', slug)
      .eq('user_id', userId)
      .single()
    
    if (!existingTransaction) {
      return { success: false, error: 'Transaction not found' }
    }
    
    const { data: transaction, error } = await supabase
      .from('transactions')
      .update(validatedUpdates)
      .eq('slug', slug)
      .eq('user_id', userId)
      .select()
      .single()
    
    if (error) {
      console.error('Error updating transaction:', error)
      return { success: false, error: 'Failed to update transaction' }
    }
    
    revalidatePath('/dashboard/transactions')
    revalidatePath(`/dashboard/transactions/${slug}`)
    return { success: true, data: transaction }
  } catch (error) {
    console.error('Error in updateTransaction:', error)
    return { success: false, error: 'Invalid update data' }
  }
}

/**
 * Delete a transaction by slug
 */
export async function deleteTransaction(slug: string) {
  try {
    const userId = await getCurrentUserId()
    const supabase = await createClient()
    
    // First check if the transaction exists and belongs to the user
    const { data: existingTransaction } = await supabase
      .from('transactions')
      .select('id')
      .eq('slug', slug)
      .eq('user_id', userId)
      .single()
    
    if (!existingTransaction) {
      return { success: false, error: 'Transaction not found' }
    }
    
    const { error } = await supabase
      .from('transactions')
      .delete()
      .eq('slug', slug)
      .eq('user_id', userId)
    
    if (error) {
      console.error('Error deleting transaction:', error)
      return { success: false, error: 'Failed to delete transaction' }
    }
    
    revalidatePath('/dashboard/transactions')
    return { success: true }
  } catch (error) {
    console.error('Error in deleteTransaction:', error)
    return { success: false, error: 'Failed to delete transaction' }
  }
}

/**
 * Get transaction statistics for the current user
 */
export async function getTransactionStats() {
  try {
    const userId = await getCurrentUserId()
    const supabase = await createClient()
    
    const { data, error } = await supabase
      .from('transactions')
      .select('type, amount')
      .eq('user_id', userId)
    
    if (error) {
      console.error('Error fetching transaction stats:', {
        message: error.message,
        details: error.details,
        hint: error.hint,
        code: error.code
      })
      return { totalIncome: 0, totalExpenses: 0, totalTransactions: 0 }
    }
    
    const stats = data?.reduce(
      (acc, transaction) => {
        acc.totalTransactions += 1
        const amount = typeof transaction.amount === 'string' ? parseFloat(transaction.amount) : transaction.amount
        if (transaction.type === 'income') {
          acc.totalIncome += amount
        } else {
          acc.totalExpenses += amount
        }
        return acc
      },
      { totalIncome: 0, totalExpenses: 0, totalTransactions: 0 }
    ) || { totalIncome: 0, totalExpenses: 0, totalTransactions: 0 }
    
    return stats
  } catch (error) {
    console.error('Error in getTransactionStats:', error)
    return { totalIncome: 0, totalExpenses: 0, totalTransactions: 0 }
  }
}

/**
 * Get transaction data for charts - monthly breakdown
 */
export async function getTransactionChartData() {
  try {
    const userId = await getCurrentUserId()
    const supabase = await createClient()
    
    // Get transactions from last 6 months
    const sixMonthsAgo = new Date()
    sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6)
    
    const { data, error } = await supabase
      .from('transactions')
      .select('type, amount, date')
      .eq('user_id', userId)
      .gte('date', sixMonthsAgo.toISOString().split('T')[0])
      .order('date', { ascending: true })
    
    if (error) {
      console.error('Error fetching chart data:', {
        message: error.message,
        details: error.details,
        hint: error.hint,
        code: error.code
      })
      return []
    }
    
    // Group by month and calculate totals
    const monthlyData: Record<string, { month: string; income: number; expenses: number; net: number }> = {}
    
    data?.forEach((transaction) => {
      const date = new Date(transaction.date)
      const monthKey = date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })
      const amount = typeof transaction.amount === 'string' ? parseFloat(transaction.amount) : transaction.amount
      
      if (!monthlyData[monthKey]) {
        monthlyData[monthKey] = { month: monthKey, income: 0, expenses: 0, net: 0 }
      }
      
      if (transaction.type === 'income') {
        monthlyData[monthKey].income += amount
      } else {
        monthlyData[monthKey].expenses += amount
      }
      
      monthlyData[monthKey].net = monthlyData[monthKey].income - monthlyData[monthKey].expenses
    })
    
    return Object.values(monthlyData)
  } catch (error) {
    console.error('Error in getTransactionChartData:', error)
    return []
  }
}

/**
 * Get category breakdown for pie chart
 */
export async function getCategoryChartData() {
  try {
    const userId = await getCurrentUserId()
    const supabase = await createClient()
    
    // Get transactions from last 3 months for category analysis
    const threeMonthsAgo = new Date()
    threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3)
    
    const { data, error } = await supabase
      .from('transactions')
      .select('category, amount, type')
      .eq('user_id', userId)
      .gte('date', threeMonthsAgo.toISOString().split('T')[0])
    
    if (error) {
      console.error('Error fetching category data:', error)
      return []
    }
    
    // Group by category and sum amounts
    const categoryData: Record<string, { category: string; amount: number; fill: string }> = {}
    const colors = [
      'hsl(var(--chart-1))',
      'hsl(var(--chart-2))', 
      'hsl(var(--chart-3))',
      'hsl(var(--chart-4))',
      'hsl(var(--chart-5))',
      'hsl(220, 70%, 50%)',
      'hsl(280, 70%, 50%)',
      'hsl(340, 70%, 50%)'
    ]
    
    data?.forEach((transaction) => {
      const { category } = transaction
      const amount = typeof transaction.amount === 'string' ? parseFloat(transaction.amount) : transaction.amount
      
      if (!categoryData[category]) {
        categoryData[category] = { 
          category, 
          amount: 0, 
          fill: colors[Object.keys(categoryData).length % colors.length] 
        }
      }
      
      categoryData[category].amount += amount
    })
    
    return Object.values(categoryData).sort((a, b) => b.amount - a.amount)
  } catch (error) {
    console.error('Error in getCategoryChartData:', error)
    return []
  }
}

/**
 * Debug function to list all transactions and their slugs
 */
export async function debugListAllTransactions() {
  try {
    const userId = await getCurrentUserId()
    const supabase = await createClient()
    
    const { data, error } = await supabase
      .from('transactions')
      .select('id, title, slug, user_id')
      .eq('user_id', userId)
    
    console.log('=== DEBUG: All transactions for user ===')
    console.log('User ID:', userId)
    console.log('Transactions:', data)
    console.log('Error:', error)
    console.log('=========================================')
    
    return data || []
  } catch (error) {
    console.error('Error in debugListAllTransactions:', error)
    return []
  }
}

 